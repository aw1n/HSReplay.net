# -*- coding: utf-8 -*-
# Generated by Django 1.10.2 on 2016-10-08 15:20
from __future__ import unicode_literals

from django.db import migrations

CREATE_TABLE_TIME_DIMENSION = """
	CREATE TABLE IF NOT EXISTS time_dimension (
		epoch_seconds	integer PRIMARY KEY,
		minute			integer NOT NULL,
		hour			integer NOT NULL,
		day				integer NOT NULL,
		month 			integer NOT NULL,
		year 			integer NOT NULL,
		day_of_week		integer NOT NULL
	);
"""
DROP_TABLE_TIME_DIMENSION = """
	DROP TABLE time_dimension;
"""

CREATE_ENSURE_TIME_DIMENSION_CREATED_FUNCTION = """
	CREATE OR REPLACE FUNCTION ensure_time_dimension_created(es numeric)
	RETURNS void AS $$
	DECLARE
		ts timestamp;
	BEGIN
		IF EXISTS (SELECT 1 FROM time_dimension t WHERE t.epoch_seconds = es) THEN
			RETURN;
		END IF;

		ts = to_timestamp(es);

		INSERT INTO time_dimension (
			epoch_seconds,
			minute,
			hour,
			day,
			month,
			year,
			day_of_week
		)
		VALUES (
			es,
			EXTRACT('minute' FROM ts),
			EXTRACT('hour' FROM ts),
			EXTRACT('day' FROM ts),
			EXTRACT('month' FROM ts),
			EXTRACT('year' FROM ts),
			EXTRACT('isodow' FROM ts)
		) ON CONFLICT DO NOTHING;

		RETURN;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_ENSURE_TIME_DIMENSION_CREATED_FUNCTION = """
	DROP FUNCTION ensure_time_dimension_created(es numeric);
"""

CREATE_TABLE_DECK_SUMMARY_STATS = """
	CREATE TABLE deck_summary_stats (
		epoch_seconds	int8 NOT NULL REFERENCES time_dimension (epoch_seconds),
		region_id		int8 NOT NULL,
		deck_id 		int8 NOT NULL REFERENCES cards_deck (id),
		player_class 	int2 NOT NULL,
		game_type		int2 NOT NULL,
		rank 			int2 NOT NULL DEFAULT -1,
		matches 		int2 NOT NULL DEFAULT 0,
		wins 			int2 NOT NULL DEFAULT 0,
		PRIMARY KEY (epoch_seconds, region_id, deck_id, player_class, game_type, rank)
	);
"""

DROP_TABLE_DECK_SUMMARY_STATS = """
	DROP TABLE deck_summary_stats;
"""

CREATE_IS_ELIGABLE_FOR_STATS_FUNCTION = """
	CREATE OR REPLACE FUNCTION is_eligable_for_stats(player games_globalgameplayer)
	RETURNS boolean AS $$
	DECLARE
		global_game games_globalgame%ROWTYPE;
	BEGIN
		IF player.account_hi IS NOT NULL
		AND player.deck_list_id IS NOT NULL
		AND player.hero_id IS NOT NULL THEN

			SELECT * INTO STRICT global_game
			FROM games_globalgame
			WHERE id = player.game_id;

			IF global_game.match_start IS NOT NULL
			AND global_game.game_type IS NOT NULL THEN
				RETURN true;
			END IF;

		END IF;

		RETURN false;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_IS_ELIGABLE_FOR_STATS_FUNCTION = """
	DROP FUNCTION is_eligable_for_stats(player games_globalgameplayer);
"""

CREATE_TO_DECK_SUMMARY_STATS_ROW_FUNCTION = """
	CREATE OR REPLACE FUNCTION to_deck_summary_stats_row(player games_globalgameplayer)
	RETURNS deck_summary_stats AS $$
	DECLARE
		ret deck_summary_stats%ROWTYPE;
	BEGIN
		ret.region_id = player.account_hi;
		ret.deck_id = player.deck_list_id;
		ret.rank = CASE WHEN player.rank IS NOT NULL THEN player.rank ELSE -1 END;
		ret.matches = 1;

		IF (player.final_state = 4) THEN
			ret.wins = 1;
		ELSE
			ret.wins = 0;
		END IF;

		SELECT c.card_class INTO STRICT ret.player_class
		FROM card c WHERE c.id = player.hero_id;

		-- We use seconds from epoch as our PK, but aggregate to the hour
		-- This gives us better storage efficiency, but leaves the door open later
		-- If we want to start aggregating to smaller intervals, like 10s or 1s
		SELECT
			round(date_part('epoch', date_trunc('hour', gg.match_start))),
			gg.game_type
		INTO STRICT ret.epoch_seconds, ret.game_type
		FROM games_globalgame gg
		WHERE gg.id = player.game_id;

		RETURN ret;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_TO_DECK_SUMMARY_STATS_ROW_FUNCTION = """
	DROP FUNCTION to_deck_summary_stats_row(player games_globalgameplayer);
"""

CREATE_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION = """
	CREATE OR REPLACE FUNCTION apply_deck_summary_stats_delta(
		delta deck_summary_stats,
		inc_decr numeric
	) RETURNS void AS $$
	DECLARE
	BEGIN
		-- incr_decr must be 1 or -1 anything else is an error
		IF (inc_decr != 1) AND (inc_decr != -1) THEN
			RAISE EXCEPTION 'inc_decr must be either 1 or -1';
		END IF;

		UPDATE deck_summary_stats
		SET matches = matches + (inc_decr * delta.matches),
			wins = wins + (inc_decr * delta.wins)
		WHERE epoch_seconds = delta.epoch_seconds
			AND region_id = delta.region_id
			AND deck_id = delta.deck_id
			AND player_class = delta.player_class
			AND game_type = delta.game_type
			AND rank = delta.rank;

		IF FOUND THEN
			-- If we successfully added the value to an existing row
			-- Then the task is complete
			RETURN;
		END IF;

		-- If we get here than there was no record to update.
		-- Check if incr_decr is -1, if so exit
		-- We can't decrement stats that don't exist

		-- The only way we should be decr stats that don't exist is if we have an error.
		-- Or we are in the brief period where the trigger is live, but we have
		-- not backfilled yet.

		IF (inc_decr = -1) THEN
			RETURN;
		END IF;

		-- If we get here than we must create the summary stats record
		-- We need to ensure the time_dimension has been pre-created
		PERFORM ensure_time_dimension_created(delta.epoch_seconds);

		INSERT INTO deck_summary_stats (
			epoch_seconds,
			region_id,
			deck_id,
			player_class,
			game_type,
			rank,
			matches,
			wins
		)
		VALUES (
			delta.epoch_seconds,
			delta.region_id,
			delta.deck_id,
			delta.player_class,
			delta.game_type,
			delta.rank,
			delta.matches,
			delta.wins
		) ON CONFLICT DO NOTHING;

	END;
	$$ LANGUAGE plpgsql;
"""

DROP_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION = """
	DROP FUNCTION apply_deck_summary_stats_delta(delta deck_summary_stats,inc_decr numeric);
"""

CREATE_MAINT_DECK_SUMMARY_STATS_FUNCTION = """
	CREATE OR REPLACE FUNCTION maint_deck_summary_stats() RETURNS TRIGGER AS $$
	BEGIN
		IF (TG_OP = 'DELETE') THEN

			IF is_eligable_for_stats(OLD) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(OLD), -1);
			END IF;

		ELSIF (TG_OP = 'UPDATE') THEN

			-- First we reverse out the old key values
			IF is_eligable_for_stats(OLD) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(OLD), -1);
			END IF;

			-- Then we update based on the new key values
			IF is_eligable_for_stats(NEW) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(NEW), 1);
			END IF;

		ELSIF (TG_OP = 'INSERT') THEN

			IF is_eligable_for_stats(NEW) THEN
				PERFORM apply_deck_summary_stats_delta(to_deck_summary_stats_row(NEW), 1);
			END IF;

		END IF;

		RETURN NULL;
	END;
	$$ LANGUAGE plpgsql;
"""

DROP_MAINT_DECK_SUMMARY_STATS_FUNCTION = """
	DROP FUNCTION maint_deck_summary_stats();
"""

CREATE_DECK_SUMMARY_STATS_TRIGGER = """
	CREATE TRIGGER maint_deck_summary_stats
	AFTER INSERT OR UPDATE OR DELETE ON games_globalgameplayer
		FOR EACH ROW EXECUTE PROCEDURE maint_deck_summary_stats();
"""

DROP_DECK_SUMMARY_STATS_TRIGGER = """
	DROP TRIGGER IF EXISTS maint_deck_summary_stats ON games_globalgameplayer;
"""


class Migration(migrations.Migration):

	dependencies = [
		('cards', '0002_auto_20160907_2216'),
		('games', '0012_auto_20161002_0229'),
	]

	operations = [
		migrations.RunSQL(
			CREATE_TABLE_TIME_DIMENSION,
			DROP_TABLE_TIME_DIMENSION
		),
		migrations.RunSQL(
			CREATE_ENSURE_TIME_DIMENSION_CREATED_FUNCTION,
			DROP_ENSURE_TIME_DIMENSION_CREATED_FUNCTION
		),
		migrations.RunSQL(
			CREATE_TABLE_DECK_SUMMARY_STATS,
			DROP_TABLE_DECK_SUMMARY_STATS
		),
		migrations.RunSQL(
			CREATE_IS_ELIGABLE_FOR_STATS_FUNCTION,
			DROP_IS_ELIGABLE_FOR_STATS_FUNCTION
		),
		migrations.RunSQL(
			CREATE_TO_DECK_SUMMARY_STATS_ROW_FUNCTION,
			DROP_TO_DECK_SUMMARY_STATS_ROW_FUNCTION
		),
		migrations.RunSQL(
			CREATE_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION,
			DROP_APPLY_DECK_SUMMARY_STATS_DELTA_FUNCTION
		),
		migrations.RunSQL(
			CREATE_MAINT_DECK_SUMMARY_STATS_FUNCTION,
			DROP_MAINT_DECK_SUMMARY_STATS_FUNCTION
		),
		migrations.RunSQL(
			CREATE_DECK_SUMMARY_STATS_TRIGGER,
			DROP_DECK_SUMMARY_STATS_TRIGGER
		),
	]
